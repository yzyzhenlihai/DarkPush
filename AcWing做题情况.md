### 数据范围判断

![image-20231202221103876](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231202221103876.png)

### 前缀和

### 差分

3729.改变数组元素

797.差分

798.差分矩阵

100.增减序列：这个题还有一点问题，对于差分数组b[1]位可以用来确定数列的种类有点不理解



### 二分

789.数的范围 	学到了二分的两个模板，但是对于模板的使用还不是很了解

1221.四平方和 		学到了对结构体的排序，需要重载“<”号，里面又一次用到了二分查找，但是对于边界的确定还不是很熟练。

用空间换时间，将枚举的结果保存，用作下一次查找的数据，查找可以用二分，也可以哈希表

```c++
struct Sum{
	int s,c,d;
	//重载<，用于结构体排序
	bool operator< (const Sum& t){
		if(s!=t.s)return s<t.s;
		if(c!=t.c)return c<t.c;
		return d<t.d;
	} 
}sum[N]; //用来存每一种组合情况 
```

1227.分巧克力   切巧克力的边长越大，能切出来的数量越少，这种变化符合二分查找的条件，运用第二个模板，查找右边界，小于等于目标值的最后一个数，这样能保证在满足小朋友数量的情况下使得巧克力的面积最大。



### 双指针

**3768.字符串删减。**我用的是模拟的方法，当遇到连续'x'的情况或者其他情况，遇到连续的就统计'x'的个数直到遇到其他情况，将统计的个数清零，并且累加需要删除的字母的个数，然后改变左右边界。最后特判一下，因r超过总长度而没有把最后一段需要删除的字母数量加上。

**799.最长连续不重复子序列。**也是利用l、r双指针，r一直向右移动，直到找到重复的数，表示已经达到这种情况的最长序列，更新最大值，然后固定r，l向右移动，直到区间内没有数字重复，继续移动r，直到序列被遍历完成。

**800.数组元素的目标和。**因为是升序的数据，涉及到查找，可以使用二分查找；或者使用哈希，将每个数是否出现存在哈希表中，查找时间复杂度O(1)；也可以使用双指针，枚举其中一个数组，因为每个数组都是升序的，所以一旦a[i]+b[j]>x，那么后面的数就可以不用枚举了。

**2816.判断子序列。**双指针逐个枚举子序列中的值，判断母序列中是否有值

**1238.日志统计。**利用双指针，我是用结构体存数值对，对id进行排序，id相同根据ts升序，然后对每一个id计算所有时间段，如果满足“热帖”条件就输出，然后判断下一个，但是这种方法时间复杂度过大，通过13/14的数据，最后一个数据超时了。题解做法：对ts进行排序，对时间段进行枚举，利用双指针，滑动窗口，统计合理时间段内每个id的点赞数，如果规定的时间段超过合理值，就移动左边界，并同时修改移出范围的id点赞数的变化（cnt[**logs[j]**]--，将点赞数减1，因为左边界缩小了），利用滑动窗口来减少重复统计时间段内的id的

点赞数。

还学到了写代码的习惯,减少代码的长度，并且pair默认是对first进行排序，就可以不用结构体内重载<，也是减少代码量

```c++
typedef pair<int,int> PII;
#define x first
#define y second
```

**1240.完全二叉树的权值。**这道题比较简单，就是注意是完全二叉树，不是满二叉树。后面一直过不了的原因竟然是变量定义的范围太小了，应该是long long 类型。之前都没注意过，都是看感觉的。

### 递推

**3777.砖块。**把全是白色和全是黑色两种情况都讨论一边，只要有满足条件的就打印出来。

**1208.翻硬币。**和3777.砖块这道题做法类似，比较简单。

**95.费解的开关。**通过第下一行来修改上一行的灯状态，保证上一行都是满足灯亮的状态的，所以说，只要确定第一行的状态，后面几行灯的状态都是确定的，然后再判断最后一行灯是不是全亮的，因为最后一行的灯是需要靠下一行修改的。通过枚举第一行所有修改的情况，总共有32种，然后递推每种情况下是否满足全亮。

题目收获：

```c++
//1.
memcpy(gcopy,g,sizeof(g));//拷贝数组，一维二维都可以 #include<cstring>
//2.
//通过设置两个向量可以方便的表示数组的上下左右
int dx[5]={0,-1,1,0,0};
int dy[5]={0,0,0,-1,1};//上下左右
//3.位运算的运用，可以将灯的状态转换成二进制运算
```



###递归

**1497.树的遍历。**运用递归，用后序遍历数列得到根节点的位置，然后递归左右子树。之前看到一句话，就是你在理解递归的时候，不要想着深入去理解栈的情况，因为层数太多了会晕，而是相信程序能完成这件事 。

**97.约数之和。**涉及到快速幂和筛质数的算法，另外通过递归分治的方法，求解等比数列，这是一种通用的方式。

**98.分形之城。**感觉很难，迟点再来看



### 并查集

**836.合并集合。**模板题，学会了并查集，就是查找两个元素是否属于同一个 集合

**1249.亲戚。**这道题和上一题一样，唯一要注意的是，需要加上ios优化。然后在打印时使用puts("Yes")，用cout也会超时。

```c++
//ios优化
ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
```

**837.连通块中点的数量。**计算同一个集合中的数量，可以定义一个sum[N],表示某集合的数量，在合并集合的时候，顺便修改sum。

**240.食物链。**利用并查集，把所有已知正确的关系都加入到一个集合（就是不管是同类、还是谁吃谁），然后维护一个”距离“数组d，用来判断某个点与根节点之间的关系，因为本题中只有3个关系，所以定义如果d=0表示是与根节点同类的，如果d=1表示可以吃根节点，如果d=2表示被根节点吃。然后d数组的维护是通过find()的路径压缩来实现的，每次查找一次，就更新d[x]为x到根节点之间的距离。先求出fa,fb判断是否已经加入过集合（表示x，y的关系可以根据之前正确的关系推出来），这里fx=find(x),已经经过了一次路径压缩，所以此时的d[x]表示的是x到fx之间的距离（可以确定与根节点之间的关系），然后如果还没有加入过集合，就需要把fx和fy归为一类，相当于出现了一个新的根节点，然后需要更新d[fx]或d[fy]（选择不同的节点当根的话，更新的d不一样），表示dx或fy到根节点之间的距离，然后等下一次查找x的根节点的时候，就会将d[x]更新（更新为x到新的根节点之间的”距离“）**注意：**在比较两个节点到根节点的距离的模的时候，不能简单的先取模在比较是否相等（表示同类），因为可能会有负数的情况。**这道题还提到了并查集可以用来维护额外信息，这一点体会的还不是很深刻（难道是因为并查集是一棵树？不知道不知道hh）**

涉及到数论中的同余定理,例如需要比较d[x]%3是否等于d[y]%3，因为”距离“会有负数存在，所以移项，转化为(d[x]%3-d[y]%3)=(d[x]-d[y])%3   （这里用到了数论的**取模运算**）

**238.银河英雄传说。**又一次理解了并查集用来维护额外信息的作用，可以用来记录集合中的元素个数，也可以维护节点到根节点之间的距离，可能还有别的，但这道题用到了这两个作用，然后在进行路径压缩的时候修改需要维护的额外信息





### 快速幂

**875.快速幂。**模板题，快速计算a^k mod p的值。详细见 Algorithm.md，学会了快速幂算法和乘法的取模运算



### 哈希

**2058.笨拙的手指。**过了13/16的数据，枚举每一位二进制数，然后记录三进制的每种变化情况，并用一个数组保存，这样子在后面就可以直接访问数组获得将修改的结果值。终于过了，好多需要注意的地方，最终要的一点就是“前导零”的问题，意思就是如果一个正确的数，二进制/三进制最高位是0，那么就一定不会写错，因为最高位的0一般不写，所以在判断最高位的时候需要去掉这些情况。然后就是只有一位的情况，需要单独判断“前导零”。学到了利用哈希表存数据，我这道题用的是数组，可以使用unordered_set<int>这个容器来存放

**840.模拟散列表。**在模拟散列表的时候，使用拉链法，需要用到用数组模拟单链表，具体见algorithm.md。然后这道题还没有解决，**总感觉不是重点，先跳过去。**



**841.字符串哈希。**又学到了关于字符串的分析，通过求解字符串前缀哈希值的方式，利用哈希值来比较字符串中子串的情况，可以不用KMP算法，感觉很牛逼这方法，记一下！！具体见algorithm.md。



### 单调队列

**830.单调栈。**所谓单调栈，就是在暴力的基础上加以改进，本来找左边第一个比它小值需要遍历所有的数，但是现在通过一些方式减少了搜索区间中的数。删除那些不会被判断的数。单调栈可以用来寻找左边或右边第一个大于或小于的某数的值

**154.滑动窗口。**



### 质数

**868.筛质数：**学到了三种筛质数的方式：1.传统方式，筛除每个数的倍数，剩下的就是质数。2.埃及筛，筛除每个质数的倍数。3.线性筛，每个合数只会被自己的最小质因子筛掉（还有点不是很理解）

**867.分解质因数：**模板题，学会了试除法，时间复杂度为O(logn)~O(根号n)之间





**Acwing130周赛**

**5294.最小数和最大数**	

**5295.三元组** 		过了一部分的测试，时间复杂度为O（2n*n）。用了y总的方法过了

**5296.边的定向**		完全不会



**Acwing131周赛**

**5363.中间数**	签到题

**5364.奶牛报数**	也是用到前缀和，分三种情况讨论，因为要第一只奶牛报数最小，所以从后面往前列举所有情况。可以用**破环成链**的方式，将环变成线性数组，需要开两倍的数组，计算前缀和。

**5365.制作地图**	没时间做了，需要利用动态规划



**Acwing132周赛**

**5367.不合群数。**就是在判断是否为质数的时候，不需要将a全部枚举，最多只用枚举1e9开根号个数，因为b的最大值是1e9，判断是否为质数只需要判断到最大值开根号的位置。判断质数没有什么简便的方法，只能通过特判减少一些数据量。



**5368.最短距离。**也不会做，需要用到并查集，图巴拉巴拉的，还没学到，迟点在再来看



**Acwing 133周赛**

**5370.最小和**

**5371.素数整除**



