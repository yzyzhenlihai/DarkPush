### 数据范围判断

![image-20231202221103876](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231202221103876.png)

### 前缀和

### 差分

3729.改变数组元素

797.差分

798.差分矩阵

100.增减序列：这个题还有一点问题，对于差分数组b[1]位可以用来确定数列的种类有点不理解



### 二分

789.数的范围 	学到了二分的两个模板，但是对于模板的使用还不是很了解

1221.四平方和 		学到了对结构体的排序，需要重载“<”号，里面又一次用到了二分查找，但是对于边界的确定还不是很熟练。

用空间换时间，将枚举的结果保存，用作下一次查找的数据，查找可以用二分，也可以哈希表

```c++
struct Sum{
	int s,c,d;
	//重载<，用于结构体排序
	bool operator< (const Sum& t){
		if(s!=t.s)return s<t.s;
		if(c!=t.c)return c<t.c;
		return d<t.d;
	} 
}sum[N]; //用来存每一种组合情况 
```

1227.分巧克力   切巧克力的边长越大，能切出来的数量越少，这种变化符合二分查找的条件，运用第二个模板，查找右边界，小于等于目标值的最后一个数，这样能保证在满足小朋友数量的情况下使得巧克力的面积最大。



### 双指针

**3768.字符串删减。**我用的是模拟的方法，当遇到连续'x'的情况或者其他情况，遇到连续的就统计'x'的个数直到遇到其他情况，将统计的个数清零，并且累加需要删除的字母的个数，然后改变左右边界。最后特判一下，因r超过总长度而没有把最后一段需要删除的字母数量加上。

**799.最长连续不重复子序列。**也是利用l、r双指针，r一直向右移动，直到找到重复的数，表示已经达到这种情况的最长序列，更新最大值，然后固定r，l向右移动，直到区间内没有数字重复，继续移动r，直到序列被遍历完成。

**800.数组元素的目标和。**因为是升序的数据，涉及到查找，可以使用二分查找；或者使用哈希，将每个数是否出现存在哈希表中，查找时间复杂度O(1)；也可以使用双指针，枚举其中一个数组，因为每个数组都是升序的，所以一旦a[i]+b[j]>x，那么后面的数就可以不用枚举了。

**2816.判断子序列。**双指针逐个枚举子序列中的值，判断母序列中是否有值

**1238.日志统计。**利用双指针，我是用结构体存数值对，对id进行排序，id相同根据ts升序，然后对每一个id计算所有时间段，如果满足“热帖”条件就输出，然后判断下一个，但是这种方法时间复杂度过大，通过13/14的数据，最后一个数据超时了。题解做法：对ts进行排序，对时间段进行枚举，利用双指针，滑动窗口，统计合理时间段内每个id的点赞数，如果规定的时间段超过合理值，就移动左边界，并同时修改移出范围的id点赞数的变化（cnt[**logs[j]**]--，将点赞数减1，因为左边界缩小了），利用滑动窗口来减少重复统计时间段内的id的

点赞数。

还学到了写代码的习惯,减少代码的长度，并且pair默认是对first进行排序，就可以不用结构体内重载<，也是减少代码量

```c++
typedef pair<int,int> PII;
#define x first
#define y second
```

**1240.完全二叉树的权值。**这道题比较简单，就是注意是完全二叉树，不是满二叉树。后面一直过不了的原因竟然是变量定义的范围太小了，应该是long long 类型。之前都没注意过，都是看感觉的。

### 递推

**3777.砖块。**把全是白色和全是黑色两种情况都讨论一边，只要有满足条件的就打印出来。

**1208.翻硬币。**和3777.砖块这道题做法类似，比较简单。

**95.费解的开关。**通过第下一行来修改上一行的灯状态，保证上一行都是满足灯亮的状态的，所以说，只要确定第一行的状态，后面几行灯的状态都是确定的，然后再判断最后一行灯是不是全亮的，因为最后一行的灯是需要靠下一行修改的。通过枚举第一行所有修改的情况，总共有32种，然后递推每种情况下是否满足全亮。

题目收获：

```c++
//1.
memcpy(gcopy,g,sizeof(g));//拷贝数组，一维二维都可以 #include<cstring>
//2.
//通过设置两个向量可以方便的表示数组的上下左右
int dx[5]={0,-1,1,0,0};
int dy[5]={0,0,0,-1,1};//上下左右
//3.位运算的运用，可以将灯的状态转换成二进制运算
```



## 递归

**1497.树的遍历。**运用递归，用后序遍历数列得到根节点的位置，然后递归左右子树。之前看到一句话，就是你在理解递归的时候，不要想着深入去理解栈的情况，因为层数太多了会晕，而是相信程序能完成这件事 。

**97.约数之和。**还没解决，涉及到快速幂和筛质数的算法





## 快速幂

**875.快速幂。**模板题，快速计算a^k mod p的值。详细见 Algorithm.md，学会了快速幂算法和乘法的取模运算



## 筛质数

**868.筛质数：**学到了三种筛质数的方式：1.传统方式，筛除每个数的倍数，剩下的就是质数。2.埃及筛，筛除每个质数的倍数。3.线性筛，每个合数只会被自己的最小质因子筛掉（还有点不是很理解）



**Acwing130周赛**

**5294.最小数和最大数**	

**5295.三元组** 		过了一部分的测试，时间复杂度为O（2n*n）。用了y总的方法过了

**5296.边的定向**		完全不会



**Acwing131周赛**

**5363.中间数**	签到题

**5364.奶牛报数**	也是用到前缀和，分三种情况讨论，因为要第一只奶牛报数最小，所以从后面往前列举所有情况。可以用**破环成链**的方式，将环变成线性数组，需要开两倍的数组，计算前缀和。

**5365.制作地图**	没时间做了，需要利用动态规划



**Acwing132周赛**

**5367.不合群数。**就是在判断是否为质数的时候，不需要将a全部枚举，最多只用枚举1e9开根号个数，因为b的最大值是1e9，判断是否为质数只需要判断到最大值开根号的位置。判断质数没有什么简便的方法，只能通过特判减少一些数据量。



**5368.最短距离。**也不会做，需要用到并查集，图巴拉巴拉的，还没学到，迟点在再来看



