## 解释器和编译器的区别

解释器：直接执行用编程语言编写的指令程序，一条一条的翻译程序，不创建中间代码。

编译器：把源代码转换成(翻译)低级语言的程序，整体进行翻译，生成中间代码或目标程序。



## 状态标志寄存器

运算器的一部分，状态寄存器用来存放两类信息：一类是体现当前指令执行结果的各种状态信息(条件码),一类是存放控制信息(PSW:程序状态字寄存器





**浮点数:**

单精度浮点数       规格化数**阶码**范围 1~254

**IEEE754和浮点数规格化：**

1. IEEE754标准有一位隐藏位，即最高有效位隐藏。而浮点数规格化**没有隐藏位**，因为它主要用于计算，不能隐藏最高有效位。
2. IEEE754标准是[浮点数](https://so.csdn.net/so/search?q=浮点数&spm=1001.2101.3001.7020)在计算机中**存储**的一种标准，而浮点数规格化主要用于浮点数的**计算**和提升精度（IEEE754标准也有提升精度的作用）。



**码距**：两个编码对应二进制不同的个数，又称**海明距离**

**最小码距称为编码集的码距**

码距越大，表示两个编码之间不同的位数越多，两个编码之间的相互转换就越难，抗干扰能力就越强。

反之，假设码距为1，任意改变一位就会变成另外一个合法编码，不具备纠错能力了。

**海明校验：**海明校验码H = 原始信息D + 校验位P

校验位都在**幂次方位**上存放

<img src="C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20230617110607641.png" alt="image-20230617110607641" style="zoom: 200%;" />



**存取时间：**存储器的访问时间，启动一次存储器操作到该操作完成所经历的时间

**时间局部性：**程序最近访问的地址再将来可能再次被访问

**空间局部性：**当访问某地址后，可能会访问其临近的地址的特性



**指令格式：** 操作码 OP + 地址码 A ( 寻址方式 I + 形式地址 D)

**寻址方式：**

立即寻址： D就是操作数本身，表示范围有限，一般用于变量赋初值。

直接寻址： D是操作数的地址。

间接寻址 ： D指向地址中的内容才是操作数的有效地址，D只是一个间接地址

寄存器寻址： D表示寄存器的编号

寄存器间接寻址： D表示的寄存器编号中存的是有效地址

相对寻址： PC + D 的值形成操作数的有效地址 ，在指令译码阶段， PC 已经 + 1了，所以是下一条指令执行的地址的值

变址寻址： D 字段增加一个变址寄存器编号字段 X ，R[X]+ D 为操作数的有效地址，X 提供修改量，D一经设定在指令执行过程中保持不变，主要应用与对**线性表**之类的数组元素进行重复访问 ，只需改变变址寄存器的值。

基址寻址：和变址寻址过程完全相同 ，R[B] + D，B基址寄存器的值一经设定不再修改



**全相联映射**： 主存地址： 主存块地址(tag) + 块内偏移(offset)

替换算法设计全部cache行



**直接相联映射**：主存按照cache大小进行分区，每个分区中包含的块数与cache的行数相同

因此主存地址分为 区地址(tag)+行索引(index)+块内偏移(offset)

**cache行号i** = 主存块号j mod (cache行数n)

**cache容量计算** = (valid+tag+8*块大小) * cache行数 /8  (B)

每个主存块只在cache特定行存放，所以不需要任何替换算法



**组相联映射**： 标记(tag)+组索引(index)+块内偏移(offset)   ,全相联映射和直接相联映射是组相联映射的特例

替换算法只涉及特定组中的行



**页式虚拟存储器**： 主存+辅存(硬盘)     **缺页异常**表示内容不在主存中

虚拟地址：虚拟页号(VPN) + 虚拟页偏移(VPO)

物理地址：物理页号(PPN) + 物理页偏移(PPO)



**MMU(在cpu中)**主要完成虚拟地址到物理地址的映射，并且能够控制内存的访问权限，而**页表**是实现上述功能的主要手段。<img src="C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20230612172132454.png" alt="image-20230612172132454" style="zoom:50%;" />



**页表项数量**和VPN有关，虚拟存储器的**页面大小**和VPO有关

**慢表**按地址访问：**PTBR**页表基址寄存器   **PTEA**页表项地址     **PTEA=PTBR + VPN * 页表项字节大小**

**快表**按内容访问：虚拟存储器的**TLB表(快表)**，本质上是容量较小得cache，用于缓冲经常访问得页表项PTE

大多采用全相联或组相联方式，且为了提高替换速度采用了**随机替换算法**

TLB组相联方式   VPN = TLBT + TLBI



 

**指令周期：**将一条指令从取出到执行完成所需要的时间

**机器周期：**一条指令划分为若干个机器周期(又称**CPU周期**)

**时钟周期：**每个机器周期又可包含若干个时钟周期



**时序发生器：**

定长指令周期同步方式，每个**状态周期**的节拍数相同，不需要考虑不同指令跳转，会造成时间浪费



**单总线结构处理器硬布线控制器：**核心部件为时序发生器

<img src="C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20230615200543150.png" alt="image-20230615200543150" style="zoom:50%;" />

上图时序产生器组合逻辑相当于时序电路中的**输出方程**

状态机组合逻辑相当于时序电路中的**状态方程**

<img src="C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20230615200115027.png" alt="image-20230615200115027" style="zoom:50%;" />



**单周期MIPS硬布线控制器：**纯组合逻辑电路，指令周期只有一个时钟周期，因此不存在多个周期电位和节拍点位，也不需要时序发生器

**现代时序硬布线控制器：**时序产生器逻辑？



**微程序控制器：**

每一条机器指令对应一段**微程序**，一段微程序包括若干条**微指令**。

控制部件向执行部件发出的控制信号称为**微命令**，接收到微命令执行的操作称作**微操作**。

一条微指令包含多个微命令(多个控制信号)。



**微指令组成：**操作控制字段 + 顺序控制字段 （判断测试字段 + 下址字段） 微指令直接给出进行某个操作的控制信号

**判断测试字段**用于实现地址逻辑转移。**下址字段**用于指示下一条微指令的地址

**注意：**每个判别测试位都对应一个分支地址

<img src="C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20230615214444858.png" alt="image-20230615214444858" style="zoom:50%;" />



**条件判别测试组合逻辑：**列出判别测试条件与输出选择信号之间的关系。



**微指令编码方式：**

1. 直接表示法 
2. 编码表示法  将互斥性微命令分成若干组，通过译码器选择某个微命令有效。需要**预留**一个不使用本组互斥性微命令中的任何一个，所以最多表示的微命令需要**减1**

3. 混合表示法 





**总线仲裁：**

1. **集中式仲裁**：总线控制逻辑基本上集中于一个设备（如CPU）中。将所有的总线请求集中起来，利用一个特定的裁决算法进行裁决
   1. 链式查询方式：离总线控制器越近的部件，其优先级越高；离总线控制器越远的部件，其优先级越低
   2. 计数器定时查询方式：计数初始值可以改变优先次序
   3. 独立请求方式：每个设备均有一对总线请求线 BRi 和总线允许线 BGi，通过各自的总线允许线 BGi 传送响应信号。
2. **分布式仲裁：**不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。仲裁号越大，优先级越高。



控制信号按照一定的顺序以此被激活，是软件时序调制，硬布线不也是依次激活吗？

如果CPU中需要时序配合的控制信号是上跳沿有效，那么这里的时钟控制端就应该是下跳沿触发？

